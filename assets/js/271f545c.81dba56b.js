"use strict";(self.webpackChunkgolang_tutorial=self.webpackChunkgolang_tutorial||[]).push([[5724],{6352:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"type-system/type-checking","title":"Type Checking","description":"Type checking in programming languages is a way to make sure that the type declaration of variables align with the way they are being used. Go is a statically typed language, similar to the likes of C++ and Java, type checking occurs at compile time.","source":"@site/docs/03-type-system/type-checking.md","sourceDirName":"03-type-system","slug":"/type-checking","permalink":"/golang-tutorial/docs/type-checking","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-type-system/type-checking.md","tags":[],"version":"current","frontMatter":{"id":"type-checking","title":"Type Checking","slug":"/type-checking"},"sidebar":"tutorialSidebar","previous":{"title":"Operations","permalink":"/golang-tutorial/docs/operations"},"next":{"title":"Type Strength","permalink":"/golang-tutorial/docs/type-strength"}}');var a=n(4848),s=n(8453);const r={id:"type-checking",title:"Type Checking",slug:"/type-checking"},o="Type Checking in Go",c={},l=[{value:"<strong>Static Type Checking</strong> in Go",id:"static-type-checking-in-go",level:2},{value:"Example",id:"example",level:3},{value:"<strong>How To Get Around Static Checking</strong>",id:"how-to-get-around-static-checking",level:2},{value:"Example",id:"example-1",level:3},{value:"<strong>Type Assertions</strong>",id:"type-assertions",level:2},{value:"Example",id:"example-2",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"type-checking-in-go",children:"Type Checking in Go"})}),"\n",(0,a.jsx)(t.p,{children:"Type checking in programming languages is a way to make sure that the type declaration of variables align with the way they are being used. Go is a statically typed language, similar to the likes of C++ and Java, type checking occurs at compile time."}),"\n",(0,a.jsxs)(t.h2,{id:"static-type-checking-in-go",children:[(0,a.jsx)(t.strong,{children:"Static Type Checking"})," in Go"]}),"\n",(0,a.jsx)(t.p,{children:"In Go, types are checked during compilation. This means that if a variable is declared as one type and being used as another, the program will error during compile time, not runtime. This drastically reduces the number of runtime errors."}),"\n",(0,a.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n\tvar my_int int = 10\n\tvar my_string string = "hello"\n\n\t// The next line will cause a compile-time error.\n\tmy_int = my_string\n\n\tfmt.Println(my_int, my_string)\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The preceding example would fail because we are trying to assign ",(0,a.jsx)(t.code,{children:"my_string"})," (a string) to ",(0,a.jsx)(t.code,{children:"my_int"})," (an int), which does not make semantic sense and thus errors. As can be seen, this error happens during compile time and not runtime."]}),"\n",(0,a.jsx)(t.h2,{id:"how-to-get-around-static-checking",children:(0,a.jsx)(t.strong,{children:"How To Get Around Static Checking"})}),"\n",(0,a.jsx)(t.p,{children:"Even though Go is statically typed, most modern languages allow a way for dynamic typing to occur through a subset of features. Go is no different with their provided behavior through interfaces. In Go, interfaces aree a type that allow values to have a runtime-determined type, as long as the required methods are implemented in both the type and the interface."}),"\n",(0,a.jsx)(t.h3,{id:"example-1",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc print_value(val interface{}) {\n\tfmt.Printf("value: %v, type: %T", val, val)\n}\n\nfunc main() {\n\tprint_value(10)\n\tprint_value("hello")\n\t// value: 10, type: int\n\t// value: hello, type: string\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the preceding example, interface"," is a type that can hold any value as well as the actual type used."]}),"\n",(0,a.jsx)(t.h2,{id:"type-assertions",children:(0,a.jsx)(t.strong,{children:"Type Assertions"})}),"\n",(0,a.jsx)(t.p,{children:"Go provides a way to determine the type witheld of an interface value. This is the part that makes interfaces actually useful as we can check the type before doing operations."}),"\n",(0,a.jsx)(t.h3,{id:"example-2",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n\tvar my_interface interface{} = "hello"\n\n\tstr, ok := my_interface.(string) // We are asserting that my_interface is type string\n\tif ok {\n\t\tfmt.Println("my_interface is a string")\n\t} else {\n\t\tfmt.Println("my_interface is not a string")\n\t}\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"Go's static type system is a very common system these days and helps ensure safety of programs. It's interface dynamic typing allows flexibility whenever deviations from the static type system are needed."})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);