"use strict";(self.webpackChunkgolang_tutorial=self.webpackChunkgolang_tutorial||[]).push([[5497],{1412:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"type-system/type-strength","title":"Type Strength","description":"Type strength is another name for how strictly a programming language enforces their type rules. Go is largely considered to be a strongly typed language because Go enforces type safety and doesn\'t allow implicit type conversions between two unrelated types.","source":"@site/docs/03-type-system/type-strength.md","sourceDirName":"03-type-system","slug":"/type-strength","permalink":"/golang-tutorial/docs/type-strength","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-type-system/type-strength.md","tags":[],"version":"current","frontMatter":{"id":"type-strength","title":"Type Strength","slug":"/type-strength"},"sidebar":"tutorialSidebar","previous":{"title":"Type Checking","permalink":"/golang-tutorial/docs/type-checking"},"next":{"title":"Arrays","permalink":"/golang-tutorial/docs/arrays"}}');var i=n(4848),s=n(8453);const a={id:"type-strength",title:"Type Strength",slug:"/type-strength"},o="Type Strength in Go",l={},c=[{value:"<strong>Type Safety</strong> in Go",id:"type-safety-in-go",level:2},{value:"Example",id:"example",level:3},{value:"<strong>Strict Typing</strong>",id:"strict-typing",level:2},{value:"Example",id:"example-1",level:3},{value:"<strong>Type Aliases</strong> in Strong Typing",id:"type-aliases-in-strong-typing",level:2},{value:"Example",id:"example-2",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"type-strength-in-go",children:"Type Strength in Go"})}),"\n",(0,i.jsx)(t.p,{children:"Type strength is another name for how strictly a programming language enforces their type rules. Go is largely considered to be a strongly typed language because Go enforces type safety and doesn't allow implicit type conversions between two unrelated types."}),"\n",(0,i.jsxs)(t.h2,{id:"type-safety-in-go",children:[(0,i.jsx)(t.strong,{children:"Type Safety"})," in Go"]}),"\n",(0,i.jsx)(t.p,{children:"Go requires explicit type conversion if we are operating with any values of different types. Implicit conversions are not allowed. Type safety helps ensure there's no unintended behavior."}),"\n",(0,i.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n\tvar diameter int = 10\n\tvar circle_pi float32 = 3.14\n\n\t// The following line would result in a compile-time error.\n\t// circumference := diameter * circle_pi\n\n\t// Instead, we must use an explicit type conversion.\n\tcircumference := float32(diameter) * circle_pi\n\n\tfmt.Println("The circumference is:", circumference)\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Here, ",(0,i.jsx)(t.code,{children:"diameter"})," (an int) cannot be multipled by ",(0,i.jsx)(t.code,{children:"circle_pi"})," (a float32) without first converting both operands to an integer or to a float."]}),"\n",(0,i.jsx)(t.h2,{id:"strict-typing",children:(0,i.jsx)(t.strong,{children:"Strict Typing"})}),"\n",(0,i.jsx)(t.p,{children:"Go enforces strict type checking in functions and variables. A function's parameters must match their types given in the parameters and a function's return type must match their type given in the function declaration."}),"\n",(0,i.jsx)(t.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc add(a int, b int) int {\n\treturn a + b\n}\n\nfunc main() {\n\tfmt.Println(add(10, 10)) // No errors\n\t// fmt.Println(add(10, 20.5)) would cause a compile-time error\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["It is perfectly fine to pass an int to a parameter of ",(0,i.jsx)(t.code,{children:"add"})," that is declared with type int. However, if we try to pass adifferent type such as a float, there will be a compile-time error."]}),"\n",(0,i.jsxs)(t.h2,{id:"type-aliases-in-strong-typing",children:[(0,i.jsx)(t.strong,{children:"Type Aliases"})," in Strong Typing"]}),"\n",(0,i.jsx)(t.p,{children:"Even if two user-defined types, which we will get into later in the course, have the same representation beneath, Go will treat them as different types unless we convert them to the same type."}),"\n",(0,i.jsx)(t.h3,{id:"example-2",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\ntype Celsius float32\ntype Fahrenheit float32\n\nfunc main() {\n\tvar temp1 Celsius = 50.0\n\tvar temp2 Fahrenheit = 51.0\n\n\t// The following would result in a compile-time error.\t\n\ttemp1 = temp2\n\n\t// Instead, we must use an explicit conversion.\n\ttemp1 = Celsius(temp2)\n\n\tfmt.Pritnln("Celsius Temperature:", temp1)\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"Go uses a strong typing system to reduce errors and unintended behaviors. Go does this by forcing explicit conversions and strict typing. This helps create safer code."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);